---
tags: [자바]
title: 스트림의 연산 (중간연산)
created: '2021-11-14T02:30:50.380Z'
modified: '2021-11-16T03:22:58.587Z'
---

# 스트림의 연산 (중간연산)

• 스트림의 다양한 연산을 이용해서 복잡한 작업들을 간단히 처리할수 있다.   
• 데이터베이스의 `SELECT`문과 비슷하다.

>스트림에 정의된 메서드 중에서 데이터 소스를 다루는 작업을 수행하는 것을 연산(openration) 이라고 한다.

• 스트림이 제공하는 연산은 `1.중간연산`과 `2.최종연산`으로 분류한다.  
• `1.중간연산`은 연산결과를 스트림으로 반환해서 연속해서 연결할 수 있다.  
• `2.최종연산`은 스트림의 요솔를 소모하면서 연산을 수행하므로 단 한번만 연산이 가능하다.

---

## 📁 스트림의 중간연산 -  skip(), limit()
• skip(), limit()은 **스트림의 일부를 잘라낼 떄 사용**
• skip(3)은 처음 3개의 요소를 건너뛰고, limit(5)는 스트림의 요소를 5개로 제한한다.
```java
Stream<T> skip(long n)
Stream<T> limit(long maxSize)
```

#### 🧩 예시
```java
Stream<Integer> skipStream = Arrays.stream(new Integer[]{1,2,3,4,5,6,7,8,9,10,11});
skipStream.skip(3).limit(5).forEach(value -> System.out.print(value + " "));
```

## 📁 스트림의 중간연산 -  filter(), distinct()
• `distinct()`는 스트림에서 중복도니 요소들을 제거
• `filter()`는 주어진 조건에 맞지 않는 요소를 걸러냄

```java
Stream<T> filter(Predicate<? super  T> predicate)
Stream<T> distinct()
```

#### 🧩 예시
• distinct
```java
IntStream distinctStream = Arrays.stream(new int[]{1,2,1,2,3,4,5,1,2,});
distinctStream.distinct().forEach(value -> System.out.print(value + " "));
```
• filter
```java
// 매개변수로 Predicate를 필요로함 ,필터를 다른조건으로 여러번 사용하는것도 가능
IntStream filterStream = Arrays.stream(new int[]{1,2,1,2,3,4,5,1,2,});
filterStream.filter(i -> i%2 == 0).filter(i -> i==2).forEach(value -> System.out.print(value + " "));
```

---


## 📁 스트림의 중간연산 -  sorted()
• 스트림을 정렬할때 사용, 지정된 `Comparator`로 정렬(int값을 반환하는 람다식을 사용하는것도 가능)
• `Comparator`를 지정하지 않으면, 스트림 요소의 기본정렬 기준으로 정렬(요소가 `Comparable`를 구현한 클래스여야한다.)

```java
Stream<T> sorted()
Stream<T> sorted(Comparator<? super T> comparator)
```

#### 🧩 예시
```java
Stream.of("dd|","absd|","hthw|","gd|","mb|").sorted().forEach(System.out::print);  // 기본정렬
Stream.of("dd|","absd|","hthw|","gd|","mb|").sorted(Comparator.naturalOrder()).forEach(System.out::print);  //  기본정렬
Stream.of("dd|","absd|","hthw|","gd|","mb|").sorted((s1,s2) -> s1.compareTo(s2)).forEach(System.out::print);  //  람다식도 가능
Stream.of("dd|","absd|","hthw|","gd|","mb|").sorted(String::compareTo).forEach(System.out::print);
Stream.of("dd|","absd|","hthw|","gd|","mb|").sorted(Comparator.reverseOrder()).forEach(System.out::print);  // 역순
Stream.of("dd|","absd|","hthw|","gd|","mb|").sorted(String.CASE_INSENSITIVE_ORDER).forEach(System.out::print);  // 대소문자 구분 안함
Stream.of("dd|","absd|","hthw|","gd|","mb|").sorted(String.CASE_INSENSITIVE_ORDER.reversed()).forEach(System.out::print);  // 대소문자 구분 안함
Stream.of("dd|","absd|","hthw|","gd|","mb|").sorted(Comparator.comparing(String::length)).forEach(System.out::print);  // 길이 순 정렬
Stream.of("dd|","absd|","hthw|","gd|","mb|").sorted(Comparator.comparingInt(String::length)).forEach(System.out::print);  // no오토박싱
```

> # 📚 Comparator
> ### 📕 Comparator 인터페이스에 대해서 
> • Comparator 인터페이스는 함수형 인터페이스로 람다식이랑 같다. 하나의 메서드만 가지고 있다. 즉, **람다식이 사용 가능하다.**
> • Comparator 인터페이스의 구현해야할 메서드는 `int compare(a, b)`이다.
> • JDK 1.8부터 `Comparator인터페이스`에 static메서드와 디폴트 메서드가 많이 추가되었는데, 이 메서드들을 이용하면 정렬이 쉬워진다.
> • 이 메서드들은 모두 🔥`Comparator<T>`🔥 를 반환하며, 가장 기본적인 메서드는 🔥`comparing()`🔥이다.
> ### 📙 comparing 작동원리
> ```java
> public static <T, U extends Comparable<? super U>> Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor)
> public static <T, U> Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor,Comparator<? super U>  > > > keyComparator)
> ```
> 1. sort() 함수는 매개변수로 `Comparator` 인터페이스를 구현한 클래스를 받는다.
> 2. (요소가 Comparable을 상속받을때) `comparing(Function keyExtractor)`이라는 디폴트 메서드를 사용하면, 인자값으로 받은 메서드를 각 인덱스마다 실행하여 값을 비교해준다.
> 3. (요소가 Comparable을 상속받지 않는다면) 정렬기준을 직접 만들어야한다. 정렬기준은 매개변수 두번째 인자로, `Comparator` 인터페이스를 구현한 클래스(람다식)를 넣어주면된다.
> ### 📒 비교대상이 기본형일경우
> `comparingInt()` 메서드를 사용하면 오토박싱과 언박싱 과정이 사라져서 더 효율적이라고한다.
> ### 📗 정렬대상을 추가할때
> thenComparing() 메서드를 사용하면된다.

#### 🧩 comparing() 예시
```java
class StreamEx6 {
    public static void main(String[] args) {
        Student[] stuArr = {
                new Student("이자바", 3, 300),
                new Student("김자바", 1, 200),
                new Student("안자바", 2, 100),
                new Student("박자바", 2, 150),
                new Student("소자바", 1, 200),
                new Student("나자바", 3, 290),
                new Student("감자바", 3, 180)
        };

        // 반별, 성적순, 이름순 정렬
        Stream.of(stuArr).sorted(Comparator.comparing(Student::getBan)      // 반별
                .thenComparing(Student::getTotalScore)      // 성적순
                .thenComparing(Student::getName))       // 이름순
                .forEach(System.out::println);
    }
}


class Student implements Comparable<Student> {
    String name;
    int ban;
    int totalScore;

    Student(String name, int ban, int totalScore) {
        this.name =name;
        this.ban =ban;
        this.totalScore =totalScore;
    }

    public String toString() {
        return String.format("[%s, %d, %d]", name, ban, totalScore).toString();
    }

    String getName() { return name;}
    int getBan() { return ban;}
    int getTotalScore() { return totalScore;}

    public int compareTo(Student s) {
        return s.totalScore - this.totalScore;
    }
}

```

---

## 📁 스트림의 중간연산 - map() 
• 스트림의 요소에 저장된 값 중에서 원하는 필드만 뽑아내거나 특정형태로 변환해야 할 때가 있다. 이때 사용하는 것이 `map`이다.
• 매개변수 T타입을 R타입으로 변환해서 반환하는 함수를 지정해야한다.
```java
Stream<R> map(Function<? super T, ? extends R> mapper);
```

#### 🧩 map() 예제
• File의 스트림에서 파일의 이름만 뽑아서 출력하고 싶을때, 다음과같이 `map()`함수를 사용할 수 있다.
```java
class StreamEx2 {
    public static void main(String[] args) {
        File[] fileArr = { new File("Ex1.java"), new File("Ex1.bak"),
                new File("Ex2.java"), new File("Ex1"), new File("Ex1.txt")
        };

        Stream<File> fileStream = Stream.of(fileArr);

        // map()으로 Stream<File>을 Stream<String>으로 변환
        Stream<String> filenameStream = fileStream.map(File::getName);
        filenameStream.forEach(System.out::println); // 모든 파일의 이름을 출력

        fileStream = Stream.of(fileArr);  // 스트림을 다시 생성

        fileStream.map(File::getName)			 // Stream<File> → Stream<String>
                .filter(s -> s.indexOf('.')!=-1)   // 확장자가 없는 것은 제외
                .map(s -> s.substring(s.indexOf('.')+1)) // 확장자만 추출
                .map(String::toUpperCase)    // 모두 대문자로 변환
                .distinct()			       //  중복 제거
                .forEach(System.out::print); // JAVABAKTXT	

        System.out.println();
    }
}
```

---

## 📁 스트림의 중간연산 - peek() 
• 연산과 연산사이에 올바르게 처리되었는지 확인하고 싶으면, `peek()`를 사용하면된다.
• `forEach()`와 달리 스트림의 요소를 소모하지 않으므로, 연산 사이에 여러번 끼워넣어도 문제가 되지 않는다.
• `filter()`나 `map()`의 결과를 확인할 때 유용하게 사용될 수 있다. 

#### 🧩 peek() 예제
```java
String[] strArr = { "1", "100", "ab", "한글", "한글과 english" };

Stream.of(strArr).filter(s -> s.length() > 2)
        .peek(System.out::println)
        .map(s -> s.toUpperCase())
        .peek(System.out::println)
        .forEach(System.out::println);
```

## 📁 스트림의 중간연산 - flatMap()
• 스트림의 타입이 Stream<T[]>인 경우, Stream<T>로 변환해야 작업이 더 편리할 때가 있다. 그럴때 `flatMap()`을 사용한다.
#### 🧩 flatMap() 예제
```java
Stream<String[]> strArrStream = Stream.of(new String[] {"abc","def","ghi"}, new String[] {"ABC","DEF","GHI"});

// Stream<Stream<String>> strStream = strArrStream.map(Arrays::stream); // map을 쓸경우 결과
Stream<String> strStream = strArrStream.flatMap(Arrays::stream);
```

---



