---
title: 스트림의 연산 (최종연산)
created: '2021-11-16T05:05:13.627Z'
modified: '2021-11-16T05:34:02.774Z'
---

# 스트림의 연산 (최종연산)

• 스트림의 다양한 연산을 이용해서 복잡한 작업들을 간단히 처리할수 있다.   
• 데이터베이스의 `SELECT`문과 비슷하다.

>스트림에 정의된 메서드 중에서 데이터 소스를 다루는 작업을 수행하는 것을 연산(openration) 이라고 한다.

• 스트림이 제공하는 연산은 `1.중간연산`과 `2.최종연산`으로 분류한다.  
• `1.중간연산`은 연산결과를 스트림으로 반환해서 연속해서 연결할 수 있다.  
• `2.최종연산`은 스트림의 요솔를 소모하면서 연산을 수행하므로 단 한번만 연산이 가능하다.

---

## 📁 스트림의 최종연산 - forEach()
• 최종 연산은 스트림의 요소를 소모해서 결과를 만들어낸다.
• 최종 연산의 결과는 스트림의 요소의 합과 같은 **단일 값**이 거나 스트림의 요소가 담긴 **배열 또는 컬랙션**일 수 있다.
• `forEach()`는 반환타입이 `void`이므로 출력하는 용도로 많이 사용된다.
#### 💡 정의
```java
void forEach(Consumer<? super T> action);
```

---

## 📁 스트림의 최종연산 - 조건검사
• 스트림의 요소에 대해 지정한 조건에 모든 요소가 일치하는지, 일부만 일치하는지, 어떤 요소도 일치 하지 않는지 확인하는데 사용
• 이 메서드들은 모두 매개변수로 `Predicate`를 요구하며, 연산결과로 `boolean`을 반환한다.
#### 💡 정의
```java
boolean allMatch(Predicate<? super T> predicate);
boolean anyMatch(Predicate<? super T> predicate);
boolean noneMatch(Predicate<? super T> predicate);
```

• 또 스트림 요소중에서 조건에 일치하는 첫번째 것을 반환하는 `findFirst()`라는 함수도 있다. 주로 조건에 맞는 스트림의 요소가 있는지 확인하는데 쓰인다. 병렬스트림의 경우 `findAny()`를 사용해야한다.

---

## 📁 스트림의 최종연산 - reduce()
• 스트림의 요소를 줄여나가면서 연산을 수행하고 최종결과를 반환한다. 그래서 매개변수 타입이 `BinaryOperator<T>`이다.
• 🔥 처음 두 요소를 가지고 연산한 결과를 가지고 그 다음 요소와 연산한다. 🔥
• 이 과정에서 스트림의 요소를 하나씩 소모하며, 스트림의 모든 요소를 소모하게되면 그 결과를 반환한다.
#### 💡 정의
```java
Optional<T> reduce(BinaryOperator<T> accumulator);
```

• 이 외에도 연산결과의 초기값(identity)을 갖는 reduce()도 있다. 이 메서드는 초기값과 스트림의 첫번째 요소로 연산을 시작한다. 이 경우 스트림의 요소가 하나도 없을 경우, 초기값이 반환되므로 반환타입은 `Optional<T>`가 아니라 `T`이다.

> `BinaryOperator<T>`는 `BiFunction`의 자손이며, `BiFunction<T,T,T>`와 동일하다.

#### 💡 정의
```java
 T reduce(T identity, BinaryOperator<T> accumulator);
 <U> U reduce(U identity,BiFunction<U, ? super T, U> accumulator,BinaryOperator<U> combiner);
```

#### 🧩 reduce() 예시
• 최종연산 `count()`와 `max()` 등은 내부적으로 모두 `reduce()`를 이용해서 아래와 같이 작성된 것이다.
```java
System.out.println(IntStream.of(1,2,3).reduce((a, b) -> a+b));
System.out.println(IntStream.of(1,2,3).reduce(1,(a,b) -> a+b));

int count = IntStream.of(1,2,3).reduce(0,(a,b) -> a+1);     // count()
int sum = IntStream.of(1,2,3).reduce(0,(a,b) -> a+b);       // sum()
int max = IntStream.of(1,2,3).reduce(Integer.MIN_VALUE,(a,b) -> a > b ? a : b);       // max()
int min = IntStream.of(1,2,3).reduce(Integer.MAX_VALUE,(a,b) -> a < b ? a : b);       // min()
```




